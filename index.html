<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙˆØ¬ÙˆÙ‡ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… â€” ÙƒØ´Ù Ø°ÙƒÙŠ Ù…Ù† Ø¨Ø¹ÙŠØ¯</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700;900&display=swap');
  
  :root {
    --primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    --success: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    --warning: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    --dark: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
    --glass: rgba(255, 255, 255, 0.1);
    --glass-border: rgba(255, 255, 255, 0.2);
    --shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
    --shadow-hover: 0 30px 60px rgba(0, 0, 0, 0.25);
    --sidebar-w: 280px;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html, body {
    height: 100%;
    font-family: 'Cairo', system-ui, -apple-system, sans-serif;
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    overflow: hidden;
  }

  .container {
    display: flex;
    height: 100vh;
    position: relative;
  }

  .camera-area {
    flex: 1;
    position: relative;
    background: #000;
    border-radius: 0 20px 20px 0;
    overflow: hidden;
    box-shadow: var(--shadow);
  }

  video#v {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  canvas#overlay {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  .hint {
    position: absolute;
    left: 20px;
    top: 20px;
    background: var(--glass);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    color: #fff;
    padding: 12px 20px;
    border-radius: 15px;
    font-weight: 600;
    font-size: 14px;
    box-shadow: var(--shadow);
    animation: fadeInSlide 0.8s ease-out;
  }

  .sidebar {
    width: var(--sidebar-w);
    background: var(--glass);
    backdrop-filter: blur(30px);
    border: 1px solid var(--glass-border);
    color: #fff;
    padding: 25px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    position: relative;
    overflow: hidden;
  }

  .sidebar::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: var(--primary);
    box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
  }

  .count-section {
    background: var(--glass);
    backdrop-filter: blur(15px);
    border: 1px solid var(--glass-border);
    padding: 25px;
    border-radius: 20px;
    text-align: center;
    box-shadow: var(--shadow);
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .count-section::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: conic-gradient(from 0deg, transparent, rgba(102, 126, 234, 0.1), transparent);
    animation: rotate 4s linear infinite;
    z-index: -1;
  }

  .count-section:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-hover);
  }

  .count-label {
    font-size: 14px;
    font-weight: 600;
    opacity: 0.8;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .count-number {
    font-size: 32px;
    font-weight: 900;
    background: var(--success);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-align: center;
  }

  .ids-section {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  .ids-header {
    font-size: 16px;
    font-weight: 700;
    margin-bottom: 15px;
    color: #fff;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .ids-header::before {
    content: 'ğŸ‘¥';
    font-size: 18px;
  }

  .ids-list {
    flex: 1;
    overflow-y: auto;
    padding-right: 8px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 10px;
    max-height: 300px;
  }

  .ids-list::-webkit-scrollbar {
    width: 4px;
  }

  .ids-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
  }

  .ids-list::-webkit-scrollbar-thumb {
    background: var(--primary);
    border-radius: 10px;
  }

  .id-item {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border: 1px solid var(--glass-border);
    padding: 12px 8px;
    border-radius: 12px;
    text-align: center;
    font-weight: 700;
    font-size: 14px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    animation: slideInUp 0.6s ease-out backwards;
  }

  .id-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.6s ease;
  }

  .id-item:hover::before {
    left: 100%;
  }

  .id-item:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    background: rgba(255, 255, 255, 0.15);
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .control-group {
    display: flex;
    gap: 10px;
  }

  .btn {
    flex: 1;
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    font-weight: 700;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.6s ease;
  }

  .btn:hover::before {
    left: 100%;
  }

  .btn-reset {
    background: var(--secondary);
    color: white;
    box-shadow: 0 8px 20px rgba(245, 87, 108, 0.3);
  }

  .btn-reset:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 30px rgba(245, 87, 108, 0.4);
  }

  .btn-pause {
    background: var(--warning);
    color: white;
    box-shadow: 0 8px 20px rgba(250, 112, 154, 0.3);
  }

  .btn-pause:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 30px rgba(250, 112, 154, 0.4);
  }

  .setting-group {
    background: var(--glass);
    backdrop-filter: blur(10px);
    border: 1px solid var(--glass-border);
    padding: 15px;
    border-radius: 15px;
    transition: all 0.3s ease;
  }

  .setting-group:hover {
    background: rgba(255, 255, 255, 0.12);
  }

  .setting-label {
    font-size: 12px;
    font-weight: 600;
    opacity: 0.9;
    margin-bottom: 8px;
    display: block;
  }

  .speed-slider {
    width: 100%;
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    outline: none;
    cursor: pointer;
    -webkit-appearance: none;
  }

  .speed-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    background: var(--success);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
    transition: all 0.3s ease;
  }

  .speed-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 6px 20px rgba(79, 172, 254, 0.6);
  }

  .checkbox-wrapper {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 5px;
  }

  .custom-checkbox {
    width: 18px;
    height: 18px;
    border: 2px solid var(--glass-border);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
  }

  .custom-checkbox.checked {
    background: var(--success);
    border-color: transparent;
  }

  .custom-checkbox.checked::after {
    content: 'âœ“';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 12px;
    font-weight: bold;
  }

  .debug {
    position: absolute;
    right: 20px;
    top: 20px;
    background: var(--glass);
    backdrop-filter: blur(20px);
    border: 1px solid var(--glass-border);
    color: #fff;
    padding: 10px 15px;
    border-radius: 10px;
    font-size: 12px;
    font-weight: 600;
    box-shadow: var(--shadow);
    animation: fadeInSlide 0.8s ease-out 0.2s both;
  }

  @keyframes fadeInSlide {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes slideInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  /* Responsive Design */
  @media (max-width: 900px) {
    .container {
      flex-direction: column-reverse;
    }
    
    .sidebar {
      width: 100%;
      height: 280px;
      flex-direction: row;
      gap: 15px;
      padding: 15px;
      border-radius: 20px 20px 0 0;
    }
    
    .count-section {
      min-width: 120px;
      padding: 15px;
    }
    
    .count-number {
      font-size: 24px;
    }
    
    .ids-section {
      flex: 1;
    }
    
    .ids-list {
      grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      max-height: 120px;
    }
    
    .controls {
      min-width: 140px;
    }
    
    .camera-area {
      border-radius: 0;
    }
    
    .hint, .debug {
      font-size: 12px;
      padding: 8px 12px;
    }
  }

  /* Animations for face detection */
  .pulse {
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }

  /* Loading animation */
  .loading {
    position: relative;
    overflow: hidden;
  }

  .loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    animation: loading 1.5s infinite;
  }

  @keyframes loading {
    0% { left: -100%; }
    100% { left: 100%; }
  }
</style>
</head>
<body>
<div class="container">
  <div class="camera-area">
    <video id="v" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
    <div class="hint">ğŸ¯ ÙˆØ¬Ù‘Ù‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù†Ø­Ùˆ Ø§Ù„Ø£Ø´Ø®Ø§Øµ â€” Ø³ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ† Ø±Ù‚Ù… Ø£Ø®Ø¶Ø± Ù„ÙƒÙ„ ÙˆØ¬Ù‡ Ø¬Ø¯ÙŠØ¯</div>
    <div class="debug" id="debugInfo">âš¡ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©...</div>
  </div>

  <div class="sidebar">
    <div class="count-section">
      <div class="count-label">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙˆØ¬ÙˆÙ‡</div>
      <div class="count-number" id="countText">0</div>
    </div>

    <div class="ids-section">
      <div class="ids-header">Ø§Ù„ÙˆØ¬ÙˆÙ‡ Ø§Ù„Ù…ÙƒØªØ´ÙØ©</div>
      <div class="ids-list" id="idsList"></div>
    </div>

    <div class="controls">
      <div class="control-group">
        <button class="btn btn-reset" id="btnReset">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
        <button class="btn btn-pause" id="btnPause">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù</button>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">Ø§Ù„ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙÙŠ Ø£ÙŠ Ù…ÙƒØ§Ù†</label>
        <div class="checkbox-wrapper">
          <div class="custom-checkbox" id="autoAssignBox"></div>
          <input type="checkbox" id="autoAssign" style="display: none;" />
        </div>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ø£Ø¨Ø·Ø£ = Ø¯Ù‚Ø© Ø£Ø¹Ù„Ù‰)</label>
        <input id="speed" type="range" min="40" max="180" step="10" value="80" class="speed-slider"/>
      </div>
    </div>
  </div>
</div>

<!-- face-api.js -->
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

<script>
/* Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø®ØµÙ‘ØµØ© Ù„Ø§ÙƒØªØ´Ø§Ù Ù…Ù† Ø¨Ø¹ÙŠØ¯ */
const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models/';
let PROCESS_INTERVAL_MS = 80;          // Ø§Ø¶Ø¨Ø· Ù…Ù† Ø§Ù„Ø´Ø±ÙŠØ·Ø› Ø£ØµØºØ± = Ø£Ø³Ø±Ø¹ Ù„ÙƒÙ† Ø£ÙƒØ«Ø± Ø­Ù…Ù„ CPU
const SSD_MIN_CONFIDENCE = 0.34;      // Ø£Ù‚Ù„ = ÙŠÙ„ØªÙ‚Ø· ÙˆØ¬ÙˆÙ‡ ØµØºÙŠØ±Ø© Ø£Ø¨Ø¹Ø¯ (ÙŠÙ…ÙƒÙ† Ø±ÙØ¹ Ø¥Ø°Ø§ Ø£Ø®Ø·Ø§Ø¡)
const ASSIGN_CONSECUTIVE = 2;         // Ø¥Ø·Ø§Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ù‚Ø¨Ù„ Ø§Ù„ØªØ¹ÙŠÙŠÙ†
const MIN_BOX_AREA_RATIO = 0.00003;   // Ù†Ù‚Ø¨Ù„ ØµÙ†Ø§Ø¯ÙŠÙ‚ ØµØºÙŠØ±Ø© (Ù„Ù„ÙƒØ´Ù Ù…Ù† Ø¨Ø¹ÙŠØ¯) â€” Ù‚Ø¯ ØªØ²ÙŠØ¯ false positivesØŒ Ù„Ø°Ø§ Ù‡Ù†Ø§Ùƒ ÙÙ„ØªØ±Ø© landmarks+embeddings
const MAX_DESCRIPTOR_DISTANCE = 0.5;  // Ø¹ØªØ¨Ø© Ø§Ù„ØªØ·Ø§Ø¨Ù‚ (0.4-0.6 Ù†Ø·Ø§Ù‚ Ø¹Ù…Ù„ÙŠ)
const MAX_TEMPLATES_PER_LABEL = 6;

const video = document.getElementById('v');
const canvas = document.getElementById('overlay');
const ctx = canvas.getContext('2d');
const debugInfo = document.getElementById('debugInfo');
const countText = document.getElementById('countText');
const idsList = document.getElementById('idsList');
const btnReset = document.getElementById('btnReset');
const btnPause = document.getElementById('btnPause');
const autoAssignCheckbox = document.getElementById('autoAssign');
const autoAssignBox = document.getElementById('autoAssignBox');
const speedSlider = document.getElementById('speed');

let modelsLoaded = false;
let running = true;
let labeledDescriptors = []; // {label: number, descriptors: [[...],...]}
let faceMatcher = null;
let assignedLabels = [];
let nextLabel = 1;
let lastLoop = 0;
let lastTime = performance.now();
let fps = 0;

// Custom checkbox handling
autoAssignBox.addEventListener('click', () => {
  autoAssignCheckbox.checked = !autoAssignCheckbox.checked;
  autoAssignBox.classList.toggle('checked', autoAssignCheckbox.checked);
});

// Ø¨Ø³ÙŠØ· â€” Ù…ØªØªØ¨Ø¹ Ù…Ø±ÙƒØ²ÙŠØ§Øª Ù„Ø¶Ù…Ø§Ù† Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„ØªØ¹Ø±Ù
class CentroidTracker {
  constructor(maxDisappeared=12, maxDistance=140){
    this.nextId = 1;
    this.objects = new Map(); // id -> {centroid,bbox,seenCount,label}
    this.disappeared = new Map();
    this.maxDisappeared = maxDisappeared;
    this.maxDistance = maxDistance;
  }
  register(centroid,bbox, knownLabel=null){
    const id = this.nextId++;
    this.objects.set(id, {centroid, bbox, seenCount:1, label: knownLabel});
    this.disappeared.set(id, 0);
    return id;
  }
  deregister(id){
    this.objects.delete(id); this.disappeared.delete(id);
  }
  update(rects){ // rects: [{centroid:[x,y], bbox:[x,y,w,h], knownLabel, descriptor}]
    if(rects.length === 0){
      for(const id of Array.from(this.disappeared.keys())){
        const v = this.disappeared.get(id) + 1; this.disappeared.set(id, v);
        const obj = this.objects.get(id); if(obj){ obj.seenCount = Math.max(0, obj.seenCount - 1); }
        if(v > this.maxDisappeared) this.deregister(id);
      }
      return this.objects;
    }
    if(this.objects.size === 0){
      for(const r of rects) this.register(r.centroid, r.bbox, r.knownLabel ?? null);
      return this.objects;
    }
    const objectIDs = Array.from(this.objects.keys());
    const objectCentroids = objectIDs.map(id => this.objects.get(id).centroid);
    const inputCentroids = rects.map(r => r.centroid);
    const D = Array(objectCentroids.length).fill(0).map(()=>Array(inputCentroids.length).fill(0));
    for(let i=0;i<objectCentroids.length;i++){
      for(let j=0;j<inputCentroids.length;j++){
        const dx = objectCentroids[i][0] - inputCentroids[j][0];
        const dy = objectCentroids[i][1] - inputCentroids[j][1];
        D[i][j] = Math.hypot(dx,dy);
      }
    }
    const usedRows = new Set(), usedCols = new Set();
    const rows = D.map((row,i)=>({min:Math.min(...row), i})).sort((a,b)=>a.min-b.min).map(x=>x.i);
    for(const row of rows){
      let minVal = Infinity, minCol = -1;
      for(let c=0;c<D[row].length;c++){
        if(usedCols.has(c)) continue;
        if(D[row][c] < minVal){ minVal = D[row][c]; minCol = c; }
      }
      if(minCol === -1) continue;
      if(minVal > this.maxDistance) continue;
      const id = objectIDs[row];
      const det = rects[minCol];
      const obj = this.objects.get(id);
      obj.centroid = det.centroid; obj.bbox = det.bbox; obj.seenCount = Math.min(20, obj.seenCount + 1);
      if(det.knownLabel && !obj.label) obj.label = det.knownLabel;
      this.disappeared.set(id, 0);
      usedRows.add(row); usedCols.add(minCol);
    }
    for(let r=0;r<D.length;r++){
      if(usedRows.has(r)) continue;
      const id = objectIDs[r]; const v = this.disappeared.get(id)+1; this.disappeared.set(id, v);
      const obj = this.objects.get(id); if(obj) obj.seenCount = Math.max(0, obj.seenCount - 1);
      if(v > this.maxDisappeared) this.deregister(id);
    }
    for(let c=0;c<rects.length;c++){
      if(usedCols.has(c)) continue;
      const d = rects[c];
      this.register(d.centroid, d.bbox, d.knownLabel ?? null);
    }
    return this.objects;
  }
  reset(){ this.nextId = 1; this.objects.clear(); this.disappeared.clear(); }
}
const tracker = new CentroidTracker(12, 140);

function rebuildFaceMatcher(){
  if(labeledDescriptors.length === 0){ faceMatcher = null; return; }
  const faceapiArr = labeledDescriptors.map(e => new faceapi.LabeledFaceDescriptors(String(e.label), e.descriptors.map(d => Float32Array.from(d))));
  faceMatcher = new faceapi.FaceMatcher(faceapiArr, MAX_DESCRIPTOR_DISTANCE || 0.6);
}

// add descriptor for label
function addDescriptorForLabel(label, descriptor){
  let entry = labeledDescriptors.find(e => e.label === label);
  if(!entry){ entry = {label: label, descriptors: []}; labeledDescriptors.push(entry); }
  // dedupe
  for(const d of entry.descriptors){
    let dist = 0; for(let i=0;i<d.length;i++){ const diff = d[i] - descriptor[i]; dist += diff*diff; } dist = Math.sqrt(dist);
    if(dist < 0.02) return;
  }
  entry.descriptors.push(Array.from(descriptor));
  if(entry.descriptors.length > MAX_TEMPLATES_PER_LABEL) entry.descriptors.shift();
  rebuildFaceMatcher();
}

// Enhanced badge draw with glow effect
function drawBadge(x, y, text) {
  const radius = 22;
  
  // Glow effect
  ctx.shadowColor = '#00f2fe';
  ctx.shadowBlur = 15;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  
  // Outer glow
  ctx.beginPath();
  ctx.fillStyle = 'rgba(79, 172, 254, 0.3)';
  ctx.arc(x, y, radius + 5, 0, Math.PI * 2);
  ctx.fill();
  
  // Main badge
  ctx.beginPath();
  const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
  gradient.addColorStop(0, '#4facfe');
  gradient.addColorStop(1, '#00f2fe');
  ctx.fillStyle = gradient;
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
  
  // Inner highlight
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.arc(x - 3, y - 3, radius * 0.6, 0, Math.PI * 2);
  ctx.fill();
  
  // Reset shadow
  ctx.shadowBlur = 0;
  
  // Text
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 16px Cairo, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x, y + 1);
}

// init: load models + open camera
async function init(){
  debugInfo.innerHTML = 'ğŸ¤– Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...';
  debugInfo.classList.add('loading');
  
  // tf backend (webgl) Ù‚Ø¯ ÙŠØ³Ø±Ù‘Ø¹
  if (tf && tf.setBackend) { 
    try{ 
      await tf.setBackend('webgl'); 
      debugInfo.innerHTML = 'âš¡ ØªØ³Ø±ÙŠØ¹ GPU Ù…ÙÙØ¹Ù‘Ù„ - Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...';
    }catch(e){
      debugInfo.innerHTML = 'ğŸ’» CPU Ù…Ø¹Ø§Ù„Ø¬Ø© - Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...';
    } 
    await tf.ready(); 
  }
  
  await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
  await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
  await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);
  
  modelsLoaded = true;
  debugInfo.classList.remove('loading');
  debugInfo.innerHTML = 'ğŸ“± Ù†Ù…Ø§Ø°Ø¬ Ø¬Ø§Ù‡Ø²Ø© â€” Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...';

  // request high-res camera
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ 
      video: { 
        facingMode: 'environment', 
        width: { ideal: 1920 }, 
        height: { ideal: 1080 } 
      }, 
      audio: false 
    });
    video.srcObject = stream; 
    await video.play();
    debugInfo.innerHTML = 'ğŸ¥ ÙƒØ§Ù…ÙŠØ±Ø§ Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø¯Ù‚Ø© Ø¬Ø§Ù‡Ø²Ø©';
  } catch(err){
    try{ 
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false }); 
      video.srcObject = stream; 
      await video.play();
      debugInfo.innerHTML = 'ğŸ¥ ÙƒØ§Ù…ÙŠØ±Ø§ Ø¬Ø§Ù‡Ø²Ø© (Ø¯Ù‚Ø© Ø¹Ø§Ø¯ÙŠØ©)';
    } catch(e){ 
      debugInfo.innerHTML = 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§: ' + e.message; 
      return; 
    }
  }

  function resize(){ 
    canvas.width = video.videoWidth; 
    canvas.height = video.videoHeight; 
    canvas.style.width = video.clientWidth + 'px'; 
    canvas.style.height = video.clientHeight + 'px'; 
  }
  
  video.addEventListener('loadeddata', resize);
  window.addEventListener('resize', resize);

  setTimeout(() => {
    debugInfo.innerHTML = 'âœ¨ Ø¬Ø§Ù‡Ø² Ù„Ù„ÙƒØ´Ù Ø§Ù„Ø°ÙƒÙŠ';
  }, 1000);
  
  requestAnimationFrame(loop);
}

let lastTimeLoop = performance.now();
async function loop(now){
  if(!running){ requestAnimationFrame(loop); return; }
  if(now - lastLoop >= PROCESS_INTERVAL_MS){
    await processFrame();
    const cur = performance.now(); 
    fps = Math.round(1000 / Math.max(1, cur - lastTime)); 
    lastTime = cur;
    debugInfo.innerHTML = `ğŸš€ ${fps} FPS | ğŸ§  ${labeledDescriptors.length} Ù†Ù…Ø§Ø°Ø¬ | ğŸ‘¥ ${assignedLabels.length} ÙˆØ¬Ù‡`;
    lastLoop = now;
  }
  requestAnimationFrame(loop);
}

async function processFrame(){
  if(!modelsLoaded) return;
  if(video.readyState < 2) return;
  
  // detectAllFaces with ssd mobilenet (better for small faces)
  const detections = await faceapi.detectAllFaces(video, new faceapi.SsdMobilenetv1Options({ minConfidence: SSD_MIN_CONFIDENCE })).withFaceLandmarks().withFaceDescriptors();
  const w = canvas.width, h = canvas.height;
  const rects = [];
  
  for(const d of detections){
    if(!d.detection || !d.descriptor || !d.landmarks) continue;
    const box = d.detection.box;
    const areaRatio = (box.width * box.height) / (w*h);
    
    if(areaRatio < MIN_BOX_AREA_RATIO) {
      // very small but might be distant face â€” keep if landmarks look good
      const left = d.landmarks.getLeftEye(), right = d.landmarks.getRightEye();
      if(!left || !right) continue;
    }
    
    // landmarks sanity: ensure eyes exist and eye distance relative to width adequate
    const leftEye = d.landmarks.getLeftEye(), rightEye = d.landmarks.getRightEye();
    if(!leftEye || !rightEye) continue;
    
    const avg = pts => { 
      let sx=0, sy=0; 
      for(const p of pts){ sx+=p.x; sy+=p.y } 
      return {x:sx/pts.length, y:sy/pts.length}; 
    };
    
    const aL = avg(leftEye), aR = avg(rightEye);
    const eyeDist = Math.hypot(aL.x - aR.x, aL.y - aR.y);
    if((eyeDist / box.width) < 0.09) continue; // too small relative to box -> reject
    
    // create centroid and knownLabel by matching descriptor to existing templates
    let knownLabel = null;
    if(faceMatcher){
      const best = faceMatcher.findBestMatch(d.descriptor);
      if(best && best.label !== 'unknown' && best.distance <= MAX_DESCRIPTOR_DISTANCE) {
        knownLabel = parseInt(best.label);
      }
    } else if(labeledDescriptors.length){
      // brute force match if matcher not built
      let bestL=null, bestDist=Infinity;
      for(const ent of labeledDescriptors){
        for(const dd of ent.descriptors){
          let dist=0; 
          for(let i=0;i<dd.length;i++){ 
            const diff = dd[i]-d.descriptor[i]; 
            dist += diff*diff; 
          } 
          dist = Math.sqrt(dist);
          if(dist < bestDist){ bestDist = dist; bestL = ent.label; }
        }
      }
      if(bestDist <= MAX_DESCRIPTOR_DISTANCE) knownLabel = bestL;
    }
    
    rects.push({ 
      centroid: [Math.floor(box.x + box.width/2), Math.floor(box.y + box.height/2)], 
      bbox: [Math.floor(box.x), Math.floor(box.y), Math.floor(box.width), Math.floor(box.height)], 
      knownLabel, 
      descriptor: d.descriptor 
    });
  }

  // feed tracker
  const objects = tracker.update(rects);

  // Enhanced drawing with modern styling
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  for(const [id,obj] of objects){
    const [x,y,wb,hb] = obj.bbox;
    
    // Enhanced box styling
    if(obj.label) {
      // Confirmed face - green glow
      ctx.shadowColor = '#00f2fe';
      ctx.shadowBlur = 10;
      ctx.strokeStyle = '#00f2fe';
      ctx.lineWidth = 3;
    } else {
      // Detecting face - orange glow
      ctx.shadowColor = '#fee140';
      ctx.shadowBlur = 8;
      ctx.strokeStyle = '#fee140';
      ctx.lineWidth = 2;
    }
    
    // Rounded rectangle
    ctx.beginPath();
    const radius = 8;
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + wb, y, x + wb, y + hb, radius);
    ctx.arcTo(x + wb, y + hb, x, y + hb, radius);
    ctx.arcTo(x, y + hb, x, y, radius);
    ctx.arcTo(x, y, x + wb, y, radius);
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Enhanced progress bar
    const progress = Math.min(1, obj.seenCount / ASSIGN_CONSECUTIVE);
    const barW = Math.floor(wb * 0.7); 
    const barH = 6;
    const bx = x + Math.floor((wb - barW)/2); 
    const by = Math.max(15, y - 25);
    
    // Progress bar background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.fillRect(bx - 1, by - 1, barW + 2, barH + 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.fillRect(bx, by, barW, barH);
    
    // Progress bar fill with gradient
    const progressWidth = Math.floor(barW * progress);
    if(progressWidth > 0) {
      const gradient = ctx.createLinearGradient(bx, by, bx + progressWidth, by);
      if(obj.label) {
        gradient.addColorStop(0, '#4facfe');
        gradient.addColorStop(1, '#00f2fe');
      } else {
        gradient.addColorStop(0, '#fa709a');
        gradient.addColorStop(1, '#fee140');
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(bx, by, progressWidth, barH);
    }
    
    // Label or count display
    if(obj.label){ 
      drawBadge(x + Math.floor(wb/2), Math.max(25, y-35), '#' + obj.label); 
    } else { 
      // Count display with modern styling
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(bx - 5, by - 20, barW + 10, 16);
      ctx.fillStyle = '#fff'; 
      ctx.font = 'bold 12px Cairo, sans-serif'; 
      ctx.textAlign = 'center'; 
      ctx.textBaseline = 'middle'; 
      ctx.fillText(Math.round(obj.seenCount).toString(), bx + Math.floor(barW/2), by - 12);
    }

    // assignment check
    if(!obj.label && obj.seenCount >= ASSIGN_CONSECUTIVE){
      // find nearest rect to this centroid
      let best=null, bestD=Infinity;
      for(const r of rects){
        const dx = r.centroid[0] - obj.centroid[0], dy = r.centroid[1] - obj.centroid[1];
        const d2 = Math.hypot(dx,dy);
        if(d2 < bestD){ bestD = d2; best = r; }
      }
      
      if(best){
        if(best.knownLabel != null){
          obj.label = best.knownLabel;
          addDescriptorForLabel(obj.label, best.descriptor);
        } else {
          const newLabel = nextLabel++;
          obj.label = newLabel;
          assignedLabels.push(newLabel);
          addDescriptorForLabel(newLabel, best.descriptor);
          
          // Enhanced feedback
          try{ 
            if(navigator.vibrate) navigator.vibrate([50, 30, 50]); 
          }catch(e){}
          
          updateSidebar();
        }
      }
    }
  }

  countText.innerText = assignedLabels.length.toString();
}

function updateSidebar(){
  idsList.innerHTML = '';
  for(let i = assignedLabels.length - 1; i >= 0; i--){
    const label = assignedLabels[i];
    const div = document.createElement('div'); 
    div.className = 'id-item'; 
    div.innerText = '#' + label;
    div.style.animationDelay = (assignedLabels.length - 1 - i) * 0.1 + 's';
    idsList.appendChild(div);
  }
  
  // Animate count
  const countElement = document.querySelector('.count-number');
  countElement.classList.add('pulse');
  setTimeout(() => countElement.classList.remove('pulse'), 1000);
}

// Enhanced reset with animation
btnReset.addEventListener('click', ()=>{
  // Add loading state
  btnReset.innerHTML = 'ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø³Ø­...';
  btnReset.disabled = true;
  
  setTimeout(() => {
    labeledDescriptors.length = 0; 
    faceMatcher = null; 
    assignedLabels.length = 0; 
    nextLabel = 1;
    tracker.reset(); 
    updateSidebar(); 
    ctx.clearRect(0,0,canvas.width,canvas.height); 
    countText.innerText = '0';
    
    btnReset.innerHTML = 'ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†';
    btnReset.disabled = false;
    
    // Success feedback
    try{ 
      if(navigator.vibrate) navigator.vibrate(200); 
    }catch(e){}
  }, 500);
});

btnPause.addEventListener('click', ()=>{ 
  running = !running; 
  if(running) {
    btnPause.innerHTML = 'â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù';
    btnPause.style.background = 'var(--warning)';
  } else {
    btnPause.innerHTML = 'â–¶ï¸ Ø§Ø³ØªØ¦Ù†Ø§Ù';
    btnPause.style.background = 'var(--success)';
  }
});

// Enhanced speed slider
speedSlider.addEventListener('input', e => { 
  PROCESS_INTERVAL_MS = parseInt(e.target.value, 10);
  
  // Visual feedback
  const percent = ((180 - e.target.value) / (180 - 40)) * 100;
  e.target.style.background = `linear-gradient(to right, #4facfe 0%, #00f2fe ${percent}%, rgba(255,255,255,0.2) ${percent}%, rgba(255,255,255,0.2) 100%)`;
});

// Initialize slider background
speedSlider.dispatchEvent(new Event('input'));

// Enhanced addDescriptorForLabel function
function addDescriptorForLabel(label, descriptor){
  let entry = labeledDescriptors.find(e => e.label === label);
  if(!entry){ 
    entry = {label: label, descriptors: []}; 
    labeledDescriptors.push(entry); 
  }
  
  // Improved deduplication
  for(const d of entry.descriptors){
    let dist=0; 
    for(let i=0;i<d.length;i++){ 
      const diff = d[i] - descriptor[i]; 
      dist += diff*diff; 
    } 
    dist = Math.sqrt(dist);
    if(dist < 0.02) return;
  }
  
  entry.descriptors.push(Array.from(descriptor));
  if(entry.descriptors.length > MAX_TEMPLATES_PER_LABEL) {
    entry.descriptors.shift();
  }
  
  // Rebuild faceMatcher with enhanced error handling
  try {
    const faceapiArr = labeledDescriptors.map(ent => 
      new faceapi.LabeledFaceDescriptors(
        String(ent.label), 
        ent.descriptors.map(dd => Float32Array.from(dd))
      )
    );
    faceMatcher = faceapiArr.length ? new faceapi.FaceMatcher(faceapiArr, MAX_DESCRIPTOR_DISTANCE) : null;
  } catch(error) {
    console.warn('Ø®Ø·Ø£ ÙÙŠ Ø¨Ù†Ø§Ø¡ FaceMatcher:', error);
    faceMatcher = null;
  }
}

// Enhanced initialization
init().catch(error => {
  console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©:', error);
  debugInfo.innerHTML = 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©: ' + error.message;
  debugInfo.style.background = 'rgba(245, 87, 108, 0.9)';
});
