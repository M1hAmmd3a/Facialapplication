<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>عدّ الأشخاص — نهائي (قوالب مثبتة)</title>
  <style>
    :root { --sidebar-w: 180px; }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Arial;}
    .container{display:flex;height:100vh;align-items:stretch;}
    .camera-area{flex:1;position:relative;background:#000;overflow:hidden;}
    video#v{width:100%;height:100%;object-fit:cover;}
    canvas#overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;}
    .hint { position:absolute; left:16px; top:12px; color:#fff; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px;}
    .sidebar{width:var(--sidebar-w);background:rgba(0,0,0,0.55);color:#fff;padding:10px;box-sizing:border-box;display:flex;flex-direction:column;}
    .count{font-size:20px;padding:6px 0;text-align:center;border-bottom:1px solid rgba(255,255,255,0.06);}
    .ids{flex:1;overflow:auto;margin-top:8px;padding-right:6px;}
    .id-item{background:rgba(255,255,255,0.06);margin:6px 0;padding:8px;border-radius:6px;text-align:center;font-weight:600;}
    .controls{margin-top:8px;display:flex;gap:8px;flex-direction:column;}
    .controls-row{display:flex;gap:8px;}
    button{padding:10px;border-radius:8px;border:0;background:#2196f3;color:white;font-weight:700}
    label{font-size:13px;color:#ddd;}
    .small{font-size:12px;color:#ddd;}
    .debug{position:absolute;right:8px;top:12px;padding:6px 8px;background:rgba(0,0,0,0.35);color:#fff;border-radius:8px;font-size:12px;}
    @media(max-width:700px){
      .container{flex-direction:column-reverse;}
      .sidebar{width:100%;height:230px;display:flex;flex-direction:row;align-items:center;padding:8px;}
      .ids{flex:1;display:flex;gap:8px;overflow:auto;align-items:center;padding:0 8px;}
      .id-item{min-width:48px;padding:6px;}
      video#v{object-fit:cover;}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="camera-area">
      <video id="v" autoplay playsinline></video>
      <canvas id="overlay"></canvas>
      <div class="hint">ضع الكاميرا على وجه الشخص → سيتم احتسابه لمرة واحدة فقط. اضغط "إعادة" لمسح الذاكرة.</div>
      <div class="debug" id="debugInfo">FPS: -- | Faces: -- | Templates: 0</div>
    </div>

    <div class="sidebar">
      <div class="count" id="countText">العدد: 0</div>
      <div class="ids" id="idsList"></div>

      <div class="controls">
        <div class="controls-row">
          <button id="btnReset">إعادة</button>
          <button id="btnPause">إيقاف</button>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
          <label class="small">Auto assign anywhere</label>
          <input type="checkbox" id="autoAssign" />
        </div>
        <div style="margin-top:6px;">
          <label class="small">حساسية (أسرع ← أدق):</label>
          <input id="sensitivity" type="range" min="1" max="4" value="2" />
        </div>
      </div>
    </div>
  </div>

  <!-- TensorFlow + BlazeFace -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>

  <script>
  // ======== إعدادات قابلة للتعديل ========
  let PROCESS_EVERY_MS = 50;        // زمن بين كل معالجة
  let RETICLE_SIZE_RATIO = 0.34;    // حجم مربع التركيز
  let ASSIGN_CONSECUTIVE = 2;       // عدد الإطارات التي يجب أن يظهر فيها الوجه قبل الاحتساب
  const MAX_TRACK_DISTANCE = 120;   // بكسل لربط المتتبّع
  // القالب (thumbnail) settings
  const TEMPLATE_SIZE = 64;         // مقاس صورة القالب (64x64)
  const TEMPLATE_SIM_THRESHOLD = 0.80; // عتبة التشابه (cosine) 0..1
  const MAX_TEMPLATES_PER_LABEL = 3; // نخزن حتى 3 عينات لكل شخص لزيادة المتانة

  // ===== DOM =====
  const video = document.getElementById('v');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const idsList = document.getElementById('idsList');
  const countText = document.getElementById('countText');
  const btnReset = document.getElementById('btnReset');
  const btnPause = document.getElementById('btnPause');
  const debugInfo = document.getElementById('debugInfo');
  const autoAssignCheckbox = document.getElementById('autoAssign');
  const sensitivity = document.getElementById('sensitivity');

  let model = null;
  let running = true;
  let lastProcess = 0;
  let lastTime = performance.now();
  let fps = 0;
  let facesThisFrame = 0;

  // offscreen canvas لصنع القوالب بسرعة
  const offcanvas = document.createElement('canvas');
  offcanvas.width = TEMPLATE_SIZE; offcanvas.height = TEMPLATE_SIZE;
  const offctx = offcanvas.getContext('2d');

  // ===== Tracker معدّل لقبول assignedLabel عند التسجيل =====
  class Tracker {
    constructor(){
      this.nextId = 1;
      this.objects = new Map(); // id -> {cx,cy,bbox,disappeared,assignedLabel,seenCount}
    }
    // register يمكنه أخذ assignedLabel (null أو رقم)
    register(cx,cy,bbox, assignedLabel = null){
      const id = this.nextId++;
      this.objects.set(id, {cx,cy,bbox,disappeared:0,assignedLabel:assignedLabel,seenCount:1});
      return id;
    }
    deregister(id){ this.objects.delete(id); }
    markAssignedLabel(id, label){ const o = this.objects.get(id); if(o) o.assignedLabel = label; }
    reset(){ this.nextId=1; this.objects.clear(); }
    update(detections){
      facesThisFrame = detections.length;
      if(detections.length === 0){
        for(const [id,obj] of this.objects){
          obj.disappeared++;
          obj.seenCount = Math.max(0, obj.seenCount-1);
          if(obj.disappeared > 20) this.deregister(id);
        }
        return this.objects;
      }

      const objectIds = Array.from(this.objects.keys());
      const objectCentroids = Array.from(this.objects.values()).map(o => [o.cx, o.cy]);
      const inputCentroids = detections.map(d => [d.cx, d.cy]);

      if(objectCentroids.length === 0){
        for(let i=0;i<inputCentroids.length;i++){
          // detections[i] قد يحتوي على .knownLabel من المرحلة السابقة
          const known = detections[i].knownLabel ?? null;
          this.register(inputCentroids[i][0], inputCentroids[i][1], detections[i].bbox, known);
        }
        return this.objects;
      }

      // مسافة الماتريكس
      const D = [];
      for(let i=0;i<objectCentroids.length;i++){
        D[i] = [];
        for(let j=0;j<inputCentroids.length;j++){
          const dx = objectCentroids[i][0]-inputCentroids[j][0];
          const dy = objectCentroids[i][1]-inputCentroids[j][1];
          D[i][j] = Math.hypot(dx,dy);
        }
      }

      const usedRows = new Set(), usedCols = new Set();
      const rows = D.map((r,i)=>({min:Math.min(...r),i})).sort((a,b)=>a.min-b.min).map(x=>x.i);
      for(const row of rows){
        let minVal = Infinity, minCol = -1;
        for(let c=0;c<D[row].length;c++){
          if(usedCols.has(c)) continue;
          if(D[row][c] < minVal){ minVal = D[row][c]; minCol = c; }
        }
        if(minCol === -1) continue;
        if(minVal > MAX_TRACK_DISTANCE) continue;
        const id = objectIds[row];
        const det = detections[minCol];
        const obj = this.objects.get(id);
        obj.cx = det.cx; obj.cy = det.cy; obj.bbox = det.bbox;
        obj.disappeared = 0;
        obj.seenCount = Math.min(10, obj.seenCount + 1);
        // إذا الكشف لديه knownLabel فنعينه هنا (يساعد لو اكتُشف قبل التسجيل)
        if(det.knownLabel && !obj.assignedLabel){
          obj.assignedLabel = det.knownLabel;
        }
        usedRows.add(row); usedCols.add(minCol);
      }

      // unmatched rows -> disappeared
      for(let r=0;r<D.length;r++){
        if(usedRows.has(r)) continue;
        const id = objectIds[r];
        const obj = this.objects.get(id);
        obj.disappeared++;
        obj.seenCount = Math.max(0, obj.seenCount - 1);
        if(obj.disappeared > 20) this.objects.delete(id);
      }

      // unmatched cols -> register (مع تمرير knownLabel إذا وُجد)
      for(let c=0;c<detections.length;c++){
        if(usedCols.has(c)) continue;
        const d = detections[c];
        this.register(d.cx, d.cy, d.bbox, d.knownLabel ?? null);
      }

      return this.objects;
    }
  }

  const tracker = new Tracker();
  const assignedOrder = []; // قائمة الترتيب النهائية (labels)
  // assignedTemplates: array of { label: number, templates: [Float32Array, ...], time: timestamp }
  const assignedTemplates = [];

  // ===== وظائف القالب وcosine similarity =====
  function makeTemplateFromBbox(bbox){
    try{
      const [x,y,w,h] = bbox;
      if(w <= 0 || h <= 0) return null;
      offctx.clearRect(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE);
      offctx.drawImage(video, x, y, w, h, 0, 0, TEMPLATE_SIZE, TEMPLATE_SIZE);
      const imgdata = offctx.getImageData(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE).data;
      const arr = new Float32Array(TEMPLATE_SIZE * TEMPLATE_SIZE);
      let idx=0;
      for(let i=0;i<imgdata.length;i+=4){
        const r = imgdata[i], g = imgdata[i+1], b = imgdata[i+2];
        const gray = (0.299*r + 0.587*g + 0.114*b) / 255;
        arr[idx++] = gray;
      }
      // normalize
      let norm = 0;
      for(let i=0;i<arr.length;i++) norm += arr[i]*arr[i];
      norm = Math.sqrt(norm) + 1e-6;
      for(let i=0;i<arr.length;i++) arr[i] = arr[i] / norm;
      return arr;
    }catch(e){
      return null;
    }
  }

  function cosineSim(a,b){
    if(!a || !b || a.length !== b.length) return 0;
    let s = 0;
    for(let i=0;i<a.length;i++) s += a[i]*b[i];
    return s;
  }

  // بحث عن أفضل قالب مطابق عبر جميع قوالب كل الـlabels
  function findMatchingTemplate(template){
    if(!template) return null;
    let bestLabel = null, bestScore = -1;
    for(const entry of assignedTemplates){
      for(const tpl of entry.templates){
        const sc = cosineSim(template, tpl);
        if(sc > bestScore){
          bestScore = sc; bestLabel = entry.label;
        }
      }
    }
    if(bestScore >= TEMPLATE_SIM_THRESHOLD) return bestLabel;
    return null;
  }

  // عند وجود قالب جديد لشخص معروف، خزّنه (حتى MAX_TEMPLATES_PER_LABEL)
  function addTemplateForLabel(label, tpl){
    if(!tpl) return;
    let entry = assignedTemplates.find(e => e.label === label);
    if(!entry){
      entry = {label: label, templates: [], time: Date.now()};
      assignedTemplates.push(entry);
    }
    // لا نكرر القوالب نفسها: فقط أضف إن لم تكن متطابقة جداً مع أي قالب موجود لهذا اللابل
    for(const existing of entry.templates){
      if(cosineSim(existing, tpl) > 0.98) return; // نفس العينة تقريباً
    }
    entry.templates.push(tpl);
    if(entry.templates.length > MAX_TEMPLATES_PER_LABEL) entry.templates.shift();
    entry.time = Date.now();
  }

  // ===== reticle + الحلقة الرئيسية =====
  function getReticleRect(w,h){
    const rw = Math.floor(w * RETICLE_SIZE_RATIO);
    const rh = Math.floor(h * RETICLE_SIZE_RATIO);
    const lx = Math.floor((w - rw)/2);
    const ly = Math.floor((h - rh)/2);
    return {x:lx,y:ly,w:rw,h:rh,left:lx,top:ly,right:lx+rw,bottom:ly+rh};
  }

  async function init(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      video.srcObject = stream;
      await video.play();
    }catch(e){
      alert('خطأ بالحصول على الكاميرا: ' + e.message);
      throw e;
    }

    function resize(){
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.style.width = video.clientWidth + 'px';
      canvas.style.height = video.clientHeight + 'px';
    }
    video.addEventListener('loadeddata', resize);
    window.addEventListener('resize', resize);

    model = await blazeface.load();
    requestAnimationFrame(loopStep);
  }

  async function loopStep(ts){
    if(!running){ lastProcess = performance.now(); requestAnimationFrame(loopStep); return; }
    const now = performance.now();
    if(now - lastProcess >= PROCESS_EVERY_MS){
      await detectAndDraw();
      const cur = performance.now();
      const dt = cur - lastTime;
      fps = Math.round(1000 / Math.max(1, dt));
      lastTime = cur;
      debugInfo.innerText = `FPS: ${fps} | Faces: ${facesThisFrame} | Templates: ${assignedTemplates.length}`;
      lastProcess = now;
    }
    requestAnimationFrame(loopStep);
  }

  async function detectAndDraw(){
    if(!model) return;
    // 1) كشف الوجوه
    const predictions = await model.estimateFaces(video, false, false);
    const w = canvas.width, h = canvas.height;
    const detections = [];

    if(predictions && predictions.length){
      for(const p of predictions){
        let x1,y1,x2,y2;
        if(p.topLeft && p.bottomRight){
          x1 = p.topLeft[0]; y1 = p.topLeft[1];
          x2 = p.bottomRight[0]; y2 = p.bottomRight[1];
        } else if(p.boundingBox){
          const bb = p.boundingBox;
          x1 = bb[0]; y1 = bb[1]; x2 = bb[0]+bb[2]; y2 = bb[1]+bb[3];
        } else continue;
        x1 = Math.max(0, Math.min(w-1, x1)); y1 = Math.max(0, Math.min(h-1, y1));
        x2 = Math.max(0, Math.min(w-1, x2)); y2 = Math.max(0, Math.min(h-1, y2));
        const bw = x2 - x1, bh = y2 - y1;
        const cx = Math.floor(x1 + bw/2), cy = Math.floor(y1 + bh/2);
        detections.push({cx, cy, bbox: [Math.floor(x1), Math.floor(y1), Math.floor(bw), Math.floor(bh)]});
      }
    }

    // 2) قبل أي تسجيل/تتبُّع: جرب مطابقة كل كشف مع القوالب المحفوظة (حتى نتجنب تسجيل الوجوه المحفوظة كـnew)
    for(const det of detections){
      const tpl = makeTemplateFromBbox(det.bbox);
      det.template = tpl;
      det.knownLabel = findMatchingTemplate(tpl); // null أو label
      // إذا اكتشفنا أنه معروف فنضع flag فوراً
    }

    // 3) مرّر detections إلى tracker (الذي يقبل knownLabel داخل detect)
    // نمرّر knownLabel ضمن الحقل det.knownLabel — tracker سيستخدمها عند التسجيل أو التحديث
    const objects = tracker.update(detections);

    // 4) رسم وقرارات التعيين النهائية:
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const ret = getReticleRect(canvas.width, canvas.height);
    ctx.strokeStyle = 'rgba(200,200,200,0.95)'; ctx.lineWidth = 3;
    ctx.strokeRect(ret.x, ret.y, ret.w, ret.h);

    // لكل كائن: لو له assignedLabel (سواء من القوالب أو جديد) نعرض علامة خضراء فوقه
    for(const [id,obj] of objects){
      const [x,y,wb,hb] = obj.bbox;
      // bbox
      ctx.strokeStyle = obj.assignedLabel ? 'rgba(0,200,0,0.95)' : 'rgba(0,180,255,0.95)';
      ctx.lineWidth = 2;
      ctx.strokeRect(x,y,wb,hb);

      // progress bar
      const progress = Math.min(1, obj.seenCount / ASSIGN_CONSECUTIVE);
      const barW = Math.floor(wb * 0.6);
      const bx = x + Math.floor((wb - barW)/2);
      const by = Math.max(12, y - 22);
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(bx, by, barW, 8);
      ctx.fillStyle = obj.assignedLabel ? 'rgba(0,200,0,0.95)' : 'rgba(255,200,0,0.95)';
      ctx.fillRect(bx, by, Math.floor(barW * progress), 8);

      // symbol: لو assignedLabel نعرض #label inside green mark فوق الشخص
      if(obj.assignedLabel){
        const mx = x + Math.floor(wb/2);
        const my = Math.max(18, y - 28);
        // دائره خضراء
        ctx.beginPath();
        ctx.fillStyle = 'rgba(0,200,0,0.95)';
        ctx.arc(mx, my, 16, 0, Math.PI*2);
        ctx.fill();
        ctx.closePath();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // assignedLabel قد تكون رقم موجود أو label سبق حفظناه
        ctx.fillText('#' + obj.assignedLabel, mx, my);
      } else {
        // لم يُعيّن بعد: نعرض عدد الإطارات المرصودة كإشارة
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(Math.round(obj.seenCount).toString(), bx + Math.floor(barW/2), by + 4);
      }

      // الآن: إذا لم يكن assignedLabel فنتحقق من شرط التعيين (كما في السابق)
      if(!obj.assignedLabel){
        const meetsSeen = obj.seenCount >= ASSIGN_CONSECUTIVE;
        const autoAssign = autoAssignCheckbox.checked;
        const inReticle = (obj.cx >= ret.left && obj.cx <= ret.right && obj.cy >= ret.top && obj.cy <= ret.bottom);
        if(meetsSeen && (autoAssign || inReticle)){
          // قبل إنشاء لابل جديد، نحاول مطابقة القالب الأخير المُلتقَط (أمان إضافي)
          const tpl = makeTemplateFromBbox(obj.bbox);
          const matchLabel = tpl ? findMatchingTemplate(tpl) : null;
          if(matchLabel){
            // إن كان مطابق -> نعيّنه لكن لا نُضيف إلى assignedOrder (لقد احتُسب مسبقًا)
            obj.assignedLabel = matchLabel;
            // نضيف قالب جديد لتحسين القوالب لهذا الشخص
            addTemplateForLabel(matchLabel, tpl);
          } else {
            // شخص جديد -> نولد label جديد (التسلسل يبدأ من 1)
            const newLabel = assignedOrder.length + 1;
            obj.assignedLabel = newLabel;
            assignedOrder.push(newLabel);
            // خزّن قالب البداية (ولتقوية التخزين نأخذ أيضاً قالبين آخرين لاحقاً)
            if(tpl) assignedTemplates.push({label: newLabel, templates: [tpl], time: Date.now()});
            updateSidebar();
          }
        }
      } else {
        // لو لديه assignedLabel مُسبق (سواء وجدناه من القوالب أو عيّناه الآن)
        // نضيف قالب إضافي لهذا الـlabel دوريًا لتحسين المستقبل (إذا لم يكن مكرر)
        try {
          if(Math.random() < 0.15){ // لا تضيف كل إطار — تؤخذ عينات نادرة لتوفير CPU
            const tpl2 = makeTemplateFromBbox(obj.bbox);
            if(tpl2) addTemplateForLabel(obj.assignedLabel, tpl2);
          }
        } catch(e){}
      }
    }

    countText.innerText = 'العدد: ' + assignedOrder.length;
  }

  function updateSidebar(){
    idsList.innerHTML = '';
    for(let i = assignedOrder.length - 1; i >= 0; i--){
      const label = assignedOrder[i];
      const div = document.createElement('div');
      div.className = 'id-item';
      div.innerText = label.toString();
      idsList.appendChild(div);
    }
  }

  // زر اعادة: يمسح كل القوالب والمتتبعات والعداد
  btnReset.addEventListener('click', ()=>{
    tracker.reset();
    assignedOrder.length = 0;
    assignedTemplates.length = 0;
    updateSidebar();
    countText.innerText = 'العدد: 0';
    ctx.clearRect(0,0,canvas.width,canvas.height);
  });
  btnPause.addEventListener('click', ()=>{
    running = !running;
    btnPause.innerText = running ? 'إيقاف' : 'استئناف';
  });

  // حساسيات السلايدر
  sensitivity.addEventListener('input', (e)=>{
    const v = parseInt(e.target.value,10);
    if(v === 1){ PROCESS_EVERY_MS = 40; RETICLE_SIZE_RATIO = 0.30; ASSIGN_CONSECUTIVE = 1; }
    else if(v === 2){ PROCESS_EVERY_MS = 50; RETICLE_SIZE_RATIO = 0.34; ASSIGN_CONSECUTIVE = 2; }
    else if(v === 3){ PROCESS_EVERY_MS = 70; RETICLE_SIZE_RATIO = 0.40; ASSIGN_CONSECUTIVE = 3; }
    else { PROCESS_EVERY_MS = 100; RETICLE_SIZE_RATIO = 0.45; ASSIGN_CONSECUTIVE = 4; }
  });

  // init
  init();
  </script>
</body>
</html>
